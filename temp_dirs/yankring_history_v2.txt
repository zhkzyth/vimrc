ighlight the brackets,V
h,v
;,v
,V
;; highlight brackets(require 'paren)(show-paren-mode 1),v
,v
')')')',V
',v
#,v
(global-set-key [M-left] 'windmove-left)          ; move to left windnow(global-set-key [M-right] 'windmove-right)        ; move to right window(global-set-key [M-up] 'windmove-up)              ; move to upper window(global-set-key [M-down] 'windmove-down)          ; move to downer window,V
http://abloz.com/huzheng/stardict-dic/,v
Repo Man,v
    ,v
    ,V
 ,v
enumerate,v
define(function() {  // Events  // -----------------  // Thanks to:  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js  //  - https://github.com/joyent/node/blob/master/lib/events.js  // Regular expression used to split event strings  var eventSplitter = /\s+/  // A module that can be mixed in to *any object* in order to provide it  // with custom events. You may bind with `on` or remove with `off` callback  // functions to an event; `trigger`-ing an event fires all callbacks in  // succession.  //  //     var object = new Events();  //     object.on('expand', function(){ alert('expanded'); });  //     object.trigger('expand');  //  function Events() {  }  // Bind one or more space separated events, `events`, to a `callback`  // function. Passing `"all"` will bind the callback to all events fired.  Events.prototype.on = function(events, callback, context) {    var cache, event, list    if (!callback) return this    cache = this.__events || (this.__events = {})    events = events.split(eventSplitter)    while (event = events.shift()) {      list = cache[event] || (cache[event] = [])      list.push(callback, context)    }    return this  }  // Remove one or many callbacks. If `context` is null, removes all callbacks  // with that function. If `callback` is null, removes all callbacks for the  // event. If `events` is null, removes all bound callbacks for all events.  Events.prototype.off = function(events, callback, context) {    var cache, event, list, i,V
http://code.google.com/p/jquery-aop/,v
https://github.com/zhkzyth/JS-reading-thoughts.git,v
http://yuilibrary.com/yui/docs/api/classes/Do.html,v
},V
  function (argument) {    if (ok) {      alert('test');    }  ,v
true,v
function_name,v
),v
define(function() {  // Events  // -----------------  // Thanks to:  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js  //  - https://github.com/joyent/node/blob/master/lib/events.js  // Regular expression used to split event strings  var eventSplitter = /\s+/  // A module that can be mixed in to *any object* in order to provide it  // with custom events. You may bind with `on` or remove with `off` callback  // functions to an event; `trigger`-ing an event fires all callbacks in  // succession.  //  //     var object = new Events();  //     object.on('expand', function(){ alert('expanded'); });  //     object.trigger('expand');  //  function Events() {  }  // Bind one or more space separated events, `events`, to a `callback`  // function. Passing `"all"` will bind the callback to all events fired.  Events.prototype.on = function(events, callback, context) {    var cache, event, list    if (!callback) return this    cache = this.__events || (this.__events = {})    events = events.split(eventSplitter)    while (event = events.shift()) {      list = cache[event] || (cache[event] = [])      list.push(callback, context)    }    return this  }  // Remove one or many callbacks. If `context` is null, removes all callbacks  // with that function. If `callback` is null, removes all callbacks for the  // event. If `events` is null, removes all bound callbacks for all events.  Events.prototype.off = function(events, callback, context) {    var cache, event, list, i    // No events, or removing *all* events.    if (!(cache = this.__events)) return this    if (!(events || callback || context)) {      delete this.__events      return this    }    events = events ? events.split(eventSplitter) : keys(cache)    // Loop through the callback list, splicing where appropriate.    while (event = events.shift()) {      list = cache[event]      if (!list) continue      if (!(callback || context)) {        delete cache[event]        continue      }      for (i = list.length - 2; i >= 0; i -= 2) {        if (!(callback && list[i] !== callback ||            context && list[i + 1] !== context)) {          list.splice(i, 2)        }      }    }    return this  }  // Trigger one or many events, firing all bound callbacks. Callbacks are  // passed the same arguments as `trigger` is, apart from the event name  // (unless you're listening on `"all"`, which will cause your callback to  // receive the true name of the event as the first argument).  Events.prototype.trigger = function(events) {    var cache, event, all, list, i, len, rest = [], args    if (!(cache = this.__events)) return this    events = events.split(eventSplitter)    // Fill up `rest` with the callback arguments.  Since we're only copying    // the tail of `arguments`, a loop is much faster than Array#slice.    for (i = 1, len = arguments.length; i < len; i++) {     rest[i - 1] = arguments[i]    }    // For each event, walk through the list of callbacks twice, first to    // trigger the event, then to trigger any `"all"` callbacks.    while (event = events.shift()) {      // Copy callback lists to prevent modification.      if (all = cache.all) all = all.slice()      if (list = cache[event]) list = list.slice()      // Execute event callbacks.      if (list) {        for (i = 0, len = list.length; i < len; i += 2) {          list[i].apply(list[i + 1] || this, rest)        }      }      // Execute "all" callbacks.      if (all) {        args = [event].concat(rest)        for (i = 0, len = all.length; i < len; i += 2) {          all[i].apply(all[i + 1] || this, args)        }      }    }    return this  }  // Mix `Events` to object instance or Class function.  Events.mixTo = function(receiver) {    receiver = receiver.prototype || receiver    var proto = Events.prototype    for (var p in proto) {      if (proto.hasOwnProperty(p)) {        receiver[p] = proto[p]      }    }  }  // Helpers  // -------//{{{  var keys = Object.keys//}}}  if (!keys) {//{{{    keys = function(o) {      var result = []      for (var name in o) {        if (o.hasOwnProperty(name)) {          result.push(name)        }      }      return result    }//}}}  }  return Events}),v
define(function() {  // Events  // -----------------  // Thanks to:  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js  //  - https://github.com/joyent/node/blob/master/lib/events.js  // Regular expression used to split event strings  var eventSplitter = /\s+/  // A module that can be mixed in to *any object* in order to provide it  // with custom events. You may bind with `on` or remove with `off` callback  // functions to an event; `trigger`-ing an event fires all callbacks in  // succession.  //  //     var object = new Events();  //     object.on('expand', function(){ alert('expanded'); });  //     object.trigger('expand');  //  function Events() {  }  // Bind one or more space separated events, `events`, to a `callback`  // function. Passing `"all"` will bind the callback to all events fired.  Events.prototype.on = function(events, callback, context) {    var cache, event, list    if (!callback) return this    cache = this.__events || (this.__events = {})    events = events.split(eventSplitter)    while (event = events.shift()) {      list = cache[event] || (cache[event] = [])      list.push(callback, context)    }    return this  }  // Remove one or many callbacks. If `context` is null, removes all callbacks  // with that function. If `callback` is null, removes all callbacks for the  // event. If `events` is null, removes all bound callbacks for all events.  Events.prototype.off = function(events, callback, context) {    var cache, event, list, i    // No events, or removing *all* events.    if (!(cache = this.__events)) return this    if (!(events || callback || context)) {      delete this.__events      return this    }    events = events ? events.split(eventSplitter) : keys(cache)    // Loop through the callback list, splicing where appropriate.    while (event = events.shift()) {      list = cache[event]      if (!list) continue      if (!(callback || context)) {        delete cache[event]        continue      }      for (i = list.length - 2; i >= 0; i -= 2) {        if (!(callback && list[i] !== callback ||            context && list[i + 1] !== context)) {          list.splice(i, 2)        }      }    }    return this  }  // Trigger one or many events, firing all bound callbacks. Callbacks are  // passed the same arguments as `trigger` is, apart from the event name  // (unless you're listening on `"all"`, which will cause your callback to  // receive the true name of the event as the first argument).  Events.prototype.trigger = function(events) {    var cache, event, all, list, i, len, rest = [], args    if (!(cache = this.__events)) return this    events = events.split(eventSplitter)    // Fill up `rest` with the callback arguments.  Since we're only copying    // the tail of `arguments`, a loop is much faster than Array#slice.    for (i = 1, len = arguments.length; i < len; i++) {     rest[i - 1] = arguments[i]    }    // For each event, walk through the list of callbacks twice, first to    // trigger the event, then to trigger any `"all"` callbacks.    while (event = events.shift()) {      // Copy callback lists to prevent modification.      if (all = cache.all) all = all.slice()      if (list = cache[event]) list = list.slice()      // Execute event callbacks.      if (list) {        for (i = 0, len = list.length; i < len; i += 2) {          list[i].apply(list[i + 1] || this, rest)        }      }      // Execute "all" callbacks.      if (all) {        args = [event].concat(rest)        for (i = 0, len = all.length; i < len; i += 2) {          all[i].apply(all[i + 1] || this, args)        }      }    }    return this  }  // Mix `Events` to object instance or Class function.  Events.mixTo = function(receiver) {    receiver = receiver.prototype || receiver    var proto = Events.prototype    for (var p in proto) {      if (proto.hasOwnProperty(p)) {        receiver[p] = proto[p]      }    }  }  // Helpers  // -------//{{{  var keys = Object.keys//}}}  if (!keys) {//{{{    keys = function(o) {      var result = []      for (var name in o) {        if (o.hasOwnProperty(name)) {          result.push(name)        }      }      return result    }//}}}  }  return Events}),V
¿?,v
叠,v
折,v
许,v
允,v
au BufWinLeave * mkviewau BufWinEnter * silent loadview,v
u,v
z,v
{,v
/,v
set foldmethod=manual   "[indent,manual,....]        ,V
set foldmethod=manual   " ¿?¿?¿?¿?,[indent,manual,....]        ,v
set foldmethod=manual   " 手动折叠,[indent,manual,....]        ,V
d,v
",v
asdasd,v
asdasd,V
"set foldmethod=indent   "fold based on indent,v
"set foldmethod=indent   "fold based on indent,V
"set nofoldenable        "dont fold by defau,V
l,v
t,v
insanely,v
"代码补全 set completeopt=preview,menu "共享剪贴板  set clipboard=unnamedplus"从不备份  set nobackup""禁止生成临时文件set noswapfile""自动保存set autowrite"set cursorline              " 突出显示当前行set magic                   " 设置魔术set guioptions-=T           " 隐藏工具栏set guioptions-=m           " 隐藏菜单栏" 去掉输入错误的提示声音set noeb" 在处理未保存或只读文件的时候，弹出确认set confirm" Tab键的宽度"set tabstop=3" 统一缩进为4"set softtabstop=3"set shiftwidth=3" 不要用空格代替制表符"set noexpandtab" 在行和段开始处使用制表符"set smarttab" 历史记录数"set history=1000" 使回格键（backspace）正常处理indent, eol, start等"set backspace=2" 允许backspace和光标键跨越行边界set whichwrap+=<,>,h,l"搜索忽略大小写set ignorecase"搜索逐字符高亮set hlsearchset incsearch"行内替换"set gdefault" 保存全局变量set viminfo+=!" 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-" 字符间插入的像素行数目set linespace=0" 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key" 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0" 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\" 高亮显示匹配的括号set showmatch" 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1" 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3" 为C程序提供自动缩进set smartindent" 自动缩进set autoindentset cindent"自动补全inoremap ( ()<ESC>iinoremap ) <c-r>=ClosePair(')')<CR>inoremap { {<CR>}<ESC>O  "according to the file type to add <CR>"inoremap { {}<ESC>iinoremap } <c-r>=ClosePair('}')<CR>inoremap [ []<ESC>iinoremap ] <c-r>=ClosePair(']')<CR>inoremap " ""<ESC>iinoremap ' ''<ESC>ifunction! ClosePair(char)   if getline('.')[col('.') - 1] == a:char      return "\<Right>"   else      return a:char   endifendfunction"differ the behaviour of {}"for Djangoautocmd FileType html inoremap {{ {{<space><space><space>}}<LEFT><lEFT><LEFT><LEFT>autocmd FileType html inoremap {% {%<space><space><space>%}<LEFT><LEFT><LEFT><LEFT>,v
" 命令行（在状态行下）的高度，默认为1，这里是2""set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\" 设置在状态行显示的信息,v
"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%],V
" 我的状态行显示的内容（包括文件类型和解码）"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")},v
" 总是显示状态行,V
"set laststatus=2,V
" 我的状态行显示的内容（包括文件类型和解码）"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]" 总是显示状态行"set laststatus=2" 命令行（在状态行下）的高度，默认为1，这里是2""set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\" 设置在状态行显示的信息,v
"set cmdheight=2,V
"set foldenable      " 允许折叠  "set foldmethod=manual   " 手动折叠  ,v
""text.vim" 高亮显示普通txt文件（需要txt.vim脚本）"au BufRead,BufNewFile *  setfiletype txt,v
" 自动缩进set autoindentset cindent,v
" 使回格键（backspace）正常处理indent, eol, start等"set backspace=2" 允许backspace和光标键跨越行边界set whichwrap+=<,>,h,l,v
"set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\" 设置在状态行显示的信息,v
" 我的状态行显示的内容（包括文件类型和解码）"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%],v
"禁止生成临时文件set noswapfile,v
"set nobackup,V
"set cursorline              " 突出显示当前行,V
set ruler                   " 打开状态栏标尺,V
,V
" 不要使用vi的键盘模式，而是vim自己的set nocompatible,v
"set foldcolumn=0"set foldmethod=indent "set foldlevel=3 "set foldenable              " 开始折叠,v
define(function() {  // Events  // -----------------  // Thanks to:  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js  //  - https://github.com/joyent/node/blob/master/lib/events.js  // Regular expression used to split event strings  var eventSplitter = /\s+/  // A module that can be mixed in to *any object* in order to provide it  // with custom events. You may bind with `on` or remove with `off` callback  // functions to an event; `trigger`-ing an event fires all callbacks in  // succession.  //  //     var object = new Events();  //     object.on('expand', function(){ alert('expanded'); });  //     object.trigger('expand');  //  function Events() {  }  // Bind one or more space separated events, `events`, to a `callback`  // function. Passing `"all"` will bind the callback to all events fired.  Events.prototype.on = function(events, callback, context) {    var cache, event, list    if (!callback) return this //keep this chain    cache = this.__events || (this.__events = {})    events = events.split(eventSplitter)    while (event = events.shift()) {      list = cache[event] || (cache[event] = [])      list.push(callback, context)    }    return this  }  // Remove one or many callbacks. If `context` is null, removes all callbacks  // with that function. If `callback` is null, removes all callbacks for the  // event. If `events` is null, removes all bound callbacks for all events.  Events.prototype.off = function(events, callback, context) {    var cache, event, list, i    // No events, or removing *all* events.    if (!(cache = this.__events)) return this    if (!(events || callback || context)) {      delete this.__events      return this    }    events = events ? events.split(eventSplitter) : keys(cache)    // Loop through the callback list, splicing where appropriate.    while (event = events.shift()) {      list = cache[event]      if (!list) continue      if (!(callback || context)) {        delete cache[event]        continue      }      for (i = list.length - 2; i >= 0; i -= 2) {        if (!(callback && list[i] !== callback ||            context && list[i + 1] !== context)) {          list.splice(i, 2)        }      }    }    return this  }  // Trigger one or many events, firing all bound callbacks. Callbacks are  // passed the same arguments as `trigger` is, apart from the event name  // (unless you're listening on `"all"`, which will cause your callback to  // receive the true name of the event as the first argument).  Events.prototype.trigger = function(events) {    var cache, event, all, list, i, len, rest = [], args    if (!(cache = this.__events)) return this    events = events.split(eventSplitter)    // Fill up `rest` with the callback arguments.  Since we're only copying    // the tail of `arguments`, a loop is much faster than Array#slice.    for (i = 1, len = arguments.length; i < len; i++) {      rest[i - 1] = arguments[i]    }    // For each event, walk through the list of callbacks twice, first to    // trigger the event, then to trigger any `"all"` callbacks.    while (event = events.shift()) {      // Copy callback lists to prevent modification.      if (all = cache.all) all = all.slice()      if (list = cache[event]) list = list.slice()      // Execute event callbacks.      if (list) {        for (i = 0, len = list.length; i < len; i += 2) {          list[i].apply(list[i + 1] || this, rest)        }      }      // Execute "all" callbacks.      if (all) {        args = [event].concat(rest)        for (i = 0, len = all.length; i < len; i += 2) {          all[i].apply(all[i + 1] || this, args)        }      }    }    return this  }  // Mix `Events` to object instance or Class function.  Events.mixTo = function(receiver) {    receiver = receiver.prototype || receiver    var proto = Events.prototype    for (var p in proto) {      if (proto.hasOwnProperty(p)) {        receiver[p] = proto[p]      }    }  }  // Helpers  // -------  var keys = Object.keys  if (!keys) {    keys = function(o) {      var result = []      for (var name in o) {        if (o.hasOwnProperty(name)) {          result.push(name)        }      }      return result    }  }  return Events}),v
define(function() {  // Events  // -----------------  // Thanks to:  //  - https://github.com/documentcloud/backbone/blob/master/backbone.js  //  - https://github.com/joyent/node/blob/master/lib/events.js  // Regular expression used to split event strings  var eventSplitter = /\s+/  // A module that can be mixed in to *any object* in order to provide it  // with custom events. You may bind with `on` or remove with `off` callback  // functions to an event; `trigger`-ing an event fires all callbacks in  // succession.  //  //     var object = new Events();  //     object.on('expand', function(){ alert('expanded'); });  //     object.trigger('expand');  //  function Events() {  }  // Bind one or more space separated events, `events`, to a `callback`  // function. Passing `"all"` will bind the callback to all events fired.  Events.prototype.on = function(events, callback, context) {    var cache, event, list    if (!callback) return this //keep this chain    cache = this.__events || (this.__events = {})    events = events.split(eventSplitter)    while (event = events.shift()) {      list = cache[event] || (cache[event] = [])      list.push(callback, context)    }    return this  }  // Remove one or many callbacks. If `context` is null, removes all callbacks  // with that function. If `callback` is null, removes all callbacks for the  // event. If `events` is null, removes all bound callbacks for all events.  Events.prototype.off = function(events, callback, context) {    var cache, event, list, i    // No events, or removing *all* events.    if (!(cache = this.__events)) return this    if (!(events || callback || context)) {      delete this.__events      return this    }    events = events ? events.split(eventSplitter) : keys(cache)    // Loop through the callback list, splicing where appropriate.    while (event = events.shift()) {      list = cache[event]      if (!list) continue      if (!(callback || context)) {        delete cache[event]        continue      }      for (i = list.length - 2; i >= 0; i -= 2) {        if (!(callback && list[i] !== callback ||            context && list[i + 1] !== context)) {          list.splice(i, 2)        }      }    }    return this  }  // Trigger one or many events, firing all bound callbacks. Callbacks are  // passed the same arguments as `trigger` is, apart from the event name  // (unless you're listening on `"all"`, which will cause your callback to  // receive the true name of the event as the first argument).  Events.prototype.trigger = function(events) {    var cache, event, all, list, i, len, rest = [], args    if (!(cache = this.__events)) return this    events = events.split(eventSplitter)    // Fill up `rest` with the callback arguments.  Since we're only copying    // the tail of `arguments`, a loop is much faster than Array#slice.    for (i = 1, len = arguments.length; i < len; i++) {      rest[i - 1] = arguments[i]    }    // For each event, walk through the list of callbacks twice, first to    // trigger the event, then to trigger any `"all"` callbacks.    while (event = events.shift()) {      // Copy callback lists to prevent modification.      if (all = cache.all) all = all.slice()      if (list = cache[event]) list = list.slice()      // Execute event callbacks.      if (list) {        for (i = 0, len = list.length; i < len; i += 2) {          list[i].apply(list[i + 1] || this, rest)        }      }      // Execute "all" callbacks.      if (all) {        args = [event].concat(rest)        for (i = 0, len = all.length; i < len; i += 2) {          all[i].apply(all[i + 1] || this, args)        }      }    }    return this  }  // Mix `Events` to object instance or Class function.  Events.mixTo = function(receiver) {    receiver = receiver.prototype || receiver    var proto = Events.prototype    for (var p in proto) {      if (proto.hasOwnProperty(p)) {        receiver[p] = proto[p]      }    }  }  // Helpers  // -------  var keys = Object.keys  if (!keys) {    keys = function(o) {      var result = []      for (var name in o) {        if (o.hasOwnProperty(name)) {          result.push(name)        }      }      return result    }  }  return Events}),V
"folding settingsset foldmethod=indent   "fold based on indentset foldnestmax=10      "deepest fold is 10 levelsset nofoldenable        "dont fold by defaultset foldlevel=1         "this is just what i use,v
git://github.com/joyent/node.git,v
https://github.com/joyent/node/blob/master/lib/events.js,v
a,v
https://github.com/zhkzyth/allThingModule.git,v
first commit~~~,V
/sbin/mount.vboxsf: mounting failed with the error: Protocol error,v
aria2c -c -s10 -x10 --out The\.Walking\.Dead\.S03E06\.\[1080i\]\[5\.1\]\[TS\]\[Secludedly\]\.TS --header 'Cookie:gdriveid=68F0264466F6F0FFDD86F1C8933C2EAE;' 'http://'{gdl,dl.{f,g,h,i,twin}}'.lixian.vip.xunlei.com/download?fid=ukjT2Hayq/yWNSJ+yGnUew341nZUM8MUAQAAAA4aCfFAzJxGRn0N+Bp7suB3QRtf&mid=666&threshold=150&tid=C6A0E73ACFBD914CA91DE23EE5EB29A3&srcid=4&verno=1&g=0E1A09F140CC9C46467D0DF81A7BB2E077411B5F&scn=t15&i=EB0D2EF2CDA4E767B0EACF40C97A92605C4B3BDC&t=6&ui=249805179&ti=97396018813&s=4643304276&m=0&n=01005D8F366E672E4404508071533033455107CA0431303830086CBF6A2E315D5B3562B9045365636C1455813B6C795D2E3562E45F00000000&ih=EB0D2EF2CDA4E767B0EACF40C97A92605C4B3BDC&fi=0&pi=97396018493&ff=0&co=E0C209AACBF7FE7E78271CD70EEEEE49&cm=1',v
https://github.com/zhkzyth/pyWebPromgramming.git,v
        print,v
        print,V
            print,V
       »,V
        »dd,V
»,v
      » ,V
»       » »,v
»»»»»»»»»»,v
»»»»»»»»»»»print '\r%d bytes processed so far' % (n,),»sys.stdout.flush()printsc.close()print 'Completed processing'elif len(sys.argv) == 3 and sys.argv[1] == 'client' and sys.argv[2].isdigit():» bytes = (int(sys.argv[2]) + 15) // 16 * 16 # round up to // 16 » message = 'capitalize this!' # 16-byte message to repeat over and over» print 'Sending', bytes, 'bytes of data, in chunks of 16 bytes' » s.connect((HOST, PORT))» sent = 0 » while sent < bytes:  » »   » s.sendall(message)    » »     » sent += len(message)       »       print '\r%d bytes sent' % (sent,),      »      sys.stdout.flush()» print » s.shutdown(socket.SHUT_WR)» print 'Receiving all the data the server sends back'» received = 0 » while True:  » »   » data = s.recv(42)    » »     » if not received:      » »       » »        » print 'The first data received says', repr(data)          »          received += len(data)         »         if not data:        »        »        break       »       print '\r%d bytes received' % (received,),» s.close()else:»print >>sys.stderr, 'usage: tcp_deadlock.py server | client <bytes>',V
5,v
#!/usr/bin/env python# Foundations of Python Network Programming - Chapter 3 - tcp_deadlock.py# TCP client and server that leave too much data waitingimport socket, syss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)HOST = '127.0.0.1'PORT = 1060if sys.argv[1:] == ['server']:»s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)»s.bind((HOST, PORT))»s.listen(1)»while True:»»print 'Listening at', s.getsockname()»»sc, sockname = s.accept()»»print 'Processing up to 1024 bytes at a time from', sockname»»n = 0»»while True:»»»message = sc.recv(1024)»»»if not message:»»»»break»»»sc.sendall(message.upper()) # send it back uppercase»»n += len(message),V
reply = recv_all(s, 16)print 'The server said', repr(reply)s.close()else:»print >>sys.stderr, 'usage: tcp_local.py server|client [host]',V
    time.sleep(5),V
»»»»»»»»,v
    PORT = int(sys.argv[2]) || PORT,V
#!/usr/bin/env python# Foundations of Python Network Programming - Chapter 3 - tcp_sixteen.py# Simple TCP client and server that send and receive 16 octetsimport socket, syss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)HOST = sys.argv.pop() if len(sys.argv) == 3 else '127.0.0.1'PORT = 1060def»»»»»»»»recv_all(sock, length):data = ''while len(data) < length:»more = sock.recv(length - len(data))»if not more:»»raise EOFError('socket closed %d bytes into a %d-byte message'»»% (len(data), length))»data += morereturn dataif sys.argv[1:] == ['server']:»s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)»s.bind((HOST, PORT))»s.listen(1)»while True:»»print 'Listening at', s.getsockname()»»sc, sockname = s.accept()»»print 'We have accepted a connection from', sockname»»print 'Socket connects', sc.getsockname(), 'and', sc.getpeername()»message = recv_all(sc, 16)»»»print 'The incoming sixteen-octet message says', repr(message)»»sc.sendall('Farewell, client')»»sc.close()»»print 'Reply sent, socket closed'elif sys.argv[1:] == ['client']:»s.connect((HOST, PORT))»print 'Client has been assigned socket name', s.getsockname()»s.sendall('Hi there, server'),V
    PORT = int(sys.argv[2]) || PORT,v
