,V
164*10=1640dd,V
164*10,v
164*10=,v
=,v
164*10==,v
zzhkzythzhkzythhkzyth,V
zhkzythzhkzythzhkzythzhkzythzhkzyth,V
zhkzyth,v
164,v
zhkzyth,V
askjdhasdhaskhd,V
164*10=1640===,v
164*10=1640==,v
164*10=1640=,v
164*10=1640,v
164*10=1640===========,v
164*10=1640==========,v
164*10=1640=========,v
164*10=1640========,v
164*10=1640=======,v
164*10=1640======,v
164*10=1640=====,v
164*10=1640====,v
453,v
\,v
 "Vim global plugin for correcting typing mistakes "Last Change: 2000 Oct 15 "Maintainer: Bram Moolenaar <Bram@vim.org> "License:      This file is placed in the public domain."if exists("loaded_typecorr")    "finish"endif"let loaded_typecorr = 1"let s:save_cpo = &cpo"set cpo&vim"iabbrev teh the"iabbrev otehr other"iabbrev wnat want"iabbrev synchronisation            "\ synchronization"let s:count = 4"if !hasmapto('<Plug>TypecorrAdd')    "map <unique> <Leader>a  <Plug>TypecorrAdd"endif"noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add"noremenu <script> Plugin.Add\ Correction      <SID>Add"noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>"function s:Add(from, correct)    "let to = input("type the correction for " . a:from . ": ")    "exe ":iabbrev " . a:from . " " . to    "if a:correct | exe "normal viws\<C-R>\" \b\e" | endif    "let s:count = s:count + 1    "echo s:count . " corrections now""endfunction"if !exists(":Correct")    "command -nargs=1  Correct  :call s:Add(<q-args>, 1)"endif"let &cpo = s:save_cpo"let words = split(getline('.','\W\+'));command! -nargs=? Filter let @a='' | execute 'g/<args>/y A' | new | setlocal bt=nofile | put! aino <C-A> <C-O>yiW<END>=<C-R>=<C-R>0<CR>164*10,v
 "Vim global plugin for correcting typing mistakes "Last Change: 2000 Oct 15 "Maintainer: Bram Moolenaar <Bram@vim.org> "License:      This file is placed in the public domain."if exists("loaded_typecorr")    "finish"endif"let loaded_typecorr = 1"let s:save_cpo = &cpo"set cpo&vim"iabbrev teh the"iabbrev otehr other"iabbrev wnat want"iabbrev synchronisation            "\ synchronization"let s:count = 4"if !hasmapto('<Plug>TypecorrAdd')    "map <unique> <Leader>a  <Plug>TypecorrAdd"endif"noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add"noremenu <script> Plugin.Add\ Correction      <SID>Add"noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>"function s:Add(from, correct)    "let to = input("type the correction for " . a:from . ": ")    "exe ":iabbrev " . a:from . " " . to    "if a:correct | exe "normal viws\<C-R>\" \b\e" | endif    "let s:count = s:count + 1    "echo s:count . " corrections now""endfunction"if !exists(":Correct")    "command -nargs=1  Correct  :call s:Add(<q-args>, 1)"endif"let &cpo = s:save_cpo"let words = split(getline('.','\W\+'));command! -nargs=? Filter let @a='' | execute 'g/<args>/y A' | new | setlocal bt=nofile | put! aino <C-A> <C-O>yiW<END>=<C-R>=<C-R>0<CR>164*10,V
 "Vim global plugin for correcting typing mistakes "Last Change: 2000 Oct 15 "Maintainer: Bram Moolenaar <Bram@vim.org> "License:      This file is placed in the public domain."if exists("loaded_typecorr")    "finish"endif"let loaded_typecorr = 1"let s:save_cpo = &cpo"set cpo&vim"iabbrev teh the"iabbrev otehr other"iabbrev wnat want"iabbrev synchronisation            "\ synchronization"let s:count = 4"if !hasmapto('<Plug>TypecorrAdd')    "map <unique> <Leader>a  <Plug>TypecorrAdd"endif"noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add"noremenu <script> Plugin.Add\ Correction      <SID>Add"noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>"function s:Add(from, correct)    "let to = input("type the correction for " . a:from . ": ")    "exe ":iabbrev " . a:from . " " . to    "if a:correct | exe "normal viws\<C-R>\" \b\e" | endif    "let s:count = s:count + 1    "echo s:count . " corrections now""endfunction"if !exists(":Correct")    "command -nargs=1  Correct  :call s:Add(<q-args>, 1)"endif"let &cpo = s:save_cpo"let words = split(getline('.','\W\+'));command! -nargs=? Filter let @a='' | execute 'g/<args>/y A' | new | setlocal bt=nofile | put! aino <C-A> <C-O>yiW<END>=<C-R>=<C-R>0<CR>8*8,v
 "Vim global plugin for correcting typing mistakes "Last Change: 2000 Oct 15 "Maintainer: Bram Moolenaar <Bram@vim.org> "License:      This file is placed in the public domain."if exists("loaded_typecorr")    "finish"endif"let loaded_typecorr = 1"let s:save_cpo = &cpo"set cpo&vim"iabbrev teh the"iabbrev otehr other"iabbrev wnat want"iabbrev synchronisation            "\ synchronization"let s:count = 4"if !hasmapto('<Plug>TypecorrAdd')    "map <unique> <Leader>a  <Plug>TypecorrAdd"endif"noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add"noremenu <script> Plugin.Add\ Correction      <SID>Add"noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>"function s:Add(from, correct)    "let to = input("type the correction for " . a:from . ": ")    "exe ":iabbrev " . a:from . " " . to    "if a:correct | exe "normal viws\<C-R>\" \b\e" | endif    "let s:count = s:count + 1    "echo s:count . " corrections now""endfunction"if !exists(":Correct")    "command -nargs=1  Correct  :call s:Add(<q-args>, 1)"endif"let &cpo = s:save_cpo"let words = split(getline('.','\W\+'));command! -nargs=? Filter let @a='' | execute 'g/<args>/y A' | new | setlocal bt=nofile | put! aino <C-A> <C-O>yiW<END>=<C-R>=<C-R>0<CR>8*8,V
,v
asdasdasdasd,V
*,v
"unmap <C-P>,V
",v
nnoremap,v
,v
,V
E475: 无效的参数: :map > test,V
C,v
!,v
https://svn.ws.netease.com/microblog/products/butter-microblog/milestones/5.6,v
"TODO dev a plugin for content shared btw vim instances...,v
"TODO dev a plugin for content shared btw vim instances...,V
NERDComment,v
hg clone https://bitbucket.org/ns9tks/vim-l9,v
map <F1> :NERDTreeToggle<cr>,v
.,v
call s:CreateMaps('nx', 'Toggle',     'Toggle', '\/'),V
map <leader>/ :call NERDCommenterToggle()<CR>,v
call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>'),v
call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>'),V
asdaasdasdada da da,V
"call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>'),v
"call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>'),V
'),v
),v
t Tlist_Auto_Open=1 let Tlist_Ctags_Cmd = '/usr/bin/ctags' let Tlist_Sort_Type = "name"    " ¿?¿?¿?¿?¿?¿?  let Tlist_Use_Right_Window = 1  " ¿?¿?¿?¿?¿?¿?¿?  let Tlist_Compart_Format = 1    " ¿?¿?¿?¿?  let Tlist_Exist_OnlyWindow = 1  " ¿?¿?¿?¿?¿?¿?buffer¿?kill¿?¿?¿?kill¿?buffer  let Tlist_File_Fold_Auto_Close = 0  " ¿?¿?¿?¿?¿?¿?¿?¿?¿?tags  let Tlist_Enable_Fold_Column = 0    " ¿?¿?¿?¿?¿?¿?¿?  "autocmd FileType java set tags+=D:\tools\java\tags  "autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  ,v
t Tlist_Auto_Open=1 let Tlist_Ctags_Cmd = '/usr/bin/ctags' let Tlist_Sort_Type = "name"    " 按照名称排序  let Tlist_Use_Right_Window = 1  " 在右侧显示窗口  let Tlist_Compart_Format = 1    " 压缩方式  let Tlist_Exist_OnlyWindow = 1  " 如果只有一个buffer，kill窗口也kill掉buffer  let Tlist_File_Fold_Auto_Close = 0  " 不要关闭其他文件的tags  let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  "autocmd FileType java set tags+=D:\tools\java\tags  "autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  ,v
t Tlist_Auto_Open=1 ,v
test,V
 ,v
NERDCommenterToggle()<CR>,v
let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  "autocmd FileType java set tags+=D:\tools\java\tags  ,V
noremap <C-Z> :update<CR>vnoremap <C-Z> <C-C>:update<CR>inoremap <C-Z> <C-O>:update<CR>"easier moving of code blocksvnoremap > >gvvnoremap < <gv"Plugin user pref"================" CTags pre"默认打开Taglist let Tlist_Auto_Open=1 let Tlist_Ctags_Cmd = '/usr/bin/ctags' let Tlist_Sort_Type = "name"    " 按照名称排序  let Tlist_Use_Right_Window = 1  " 在右侧显示窗口  let Tlist_Compart_Format = 1    " 压缩方式  let Tlist_Exist_OnlyWindow = 1  " 如果只有一个buffer，kill窗口也kill掉buffer  let Tlist_File_Fold_Auto_Close = 0  " 不要关闭其他文件的tags  let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  "autocmd FileType java set tags+=D:\tools\java\tags  "autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  let Tlist_Show_One_File=1            "不同时显示多个文件的tag，只显示当前文件的"BufExplorer"map <C-x> :BufExplorer<cr>"TODO more buf actions"NERDTree,oh~~mymap <F1> :NERDTreeToggle<cr>"nerd,v
vnoremap > >gvvnoremap < <gv"Plugin user pref"================" CTags pre"默认打开Taglist let Tlist_Auto_Open=1 let Tlist_Ctags_Cmd = '/usr/bin/ctags' let Tlist_Sort_Type = "name"    " 按照名称排序  let Tlist_Use_Right_Window = 1  " 在右侧显示窗口  let Tlist_Compart_Format = 1    " 压缩方式  let Tlist_Exist_OnlyWindow = 1  " 如果只有一个buffer，kill窗口也kill掉buffer  let Tlist_File_Fold_Auto_Close = 0  " 不要关闭其他文件的tags  let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  "autocmd FileType java set tags+=D:\tools\java\tags  "autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  let Tlist_Show_One_File=1            "不同时显示多个文件的tag，只显示当前文件的"BufExplorer"map <C-x> :BufExplorer<cr>"TODO more buf actions"NERDTree,oh~~mymap <F1> :NERDTreeToggle<cr>"nerd,v
map <C-x> :BufExplorer<cr>,v
map <leader>/ :call ToggleComment()<CR>,V
map <leader>/ :call ToggleComment()<CR>,v
"TODO 查阅其他人写的comment插件，改成单个键就能完成comment\"     尝试block comment的用法" Comments range (handles multiple file types)function! ToggleComment() range   if &filetype == "c" || &filetype == "php" || &filetype == "css" || &filetype == 'html' || &filetype == 'xml' || &filetype == 'xslt'            \ || &filetype == 'xsd'      if getline('.') !~ '^[/(]\*\|<!--\(.*\)$'         if getline('.') =~ '^\*'            let tgComStr ='s/^\(.*\)$/\/\* \1 \*\//'         else            let tgComStr ='s/^\(.*\)$/<!-- \1 -->/'         endif      else         let tgComStr ='s/^\([/(]\*\|<!--\) \(.*\) \(\*[/)]\|-->\)$/\2/'      endif      execute ":" . a:firstline . "," . a:lastline . tgComStr   else      "not comment yet      if getline('.') !~ '^\(#\|\"\|\/\/\)'         if &filetype == "java" || &filetype == "cpp" || &filetype == "cs" || &filetype == "javascript" || &filetype == "js"            let commentString = "//"         elseif &filetype == "vim"            let commentString = '"'         else            let commentString = "#"          endif         execute ":" . a:firstline . "," . a:lastline . 's,^,' . commentString . ','      else         if &filetype == "java" || &filetype == "cpp" || &filetype == "cs"            let commentString = "//"         elseif &filetype == "vim"            let commentString = '"'         else            let commentString = "#"         endif         execute ":" . a:firstline . "," . a:lastline . 's,^' . commentString . ',,'      endif   endifendfunction"---------------------end of comment function try----------------------------------------------------",v
git://github.com/scrooloose/nerdcommenter.git,v
import "",V
zhkzyth I asd I bbbb bbb,V
test,v
bbb,v
asd,v
1,v
the,V
zhk,v
zhkz,v
zhkzy,v
zhkzyt,v
asjkdhaskjdhasjkdh,v
lsjdlkajs2,v
askldjaskldjasljkd,v
let,v
hahah,V
l,v
teh,v
endif,v
     let &cpo = s:save_cpo,v
     let &cpo = s:save_cpo,V
       if a:correct | exe "normal viws\<C-R>\" \b\e" | endif,V
" Vim global plugin for correcting typing mistakes  2     " Last Change: 2000 Oct 15  3     " Maintainer: Bram Moolenaar <Bram@vim.org>  4     " License:      This file is placed in the public domain.  5  6     if exists("loaded_typecorr")  7       finish  8     endif  9     let loaded_typecorr = 1 10 11     let s:save_cpo = &cpo 12     set cpo&vim 13 14     iabbrev teh the 15     iabbrev otehr other 16     iabbrev wnat want 17     iabbrev synchronisation 18             \ synchronization 19     let s:count = 4 20 21     if !hasmapto('<Plug>TypecorrAdd') 22       map <unique> <Leader>a  <Plug>TypecorrAdd 23     endif 24     noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add 25 26     noremenu <script> Plugin.Add\ Correction      <SID>Add 27 28     noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR> 29 30     function s:Add(from, correct) 31       let to = input("type the correction for " . a:from . ": ") 32       exe ":iabbrev " . a:from . " " . to 33       if a:correct | exe "normal viws\<C-R>\" \b\e" | endif 34       let s:count = s:count + 1 35       echo s:count . " corrections now" 36     endfunction 37 38     if !exists(":Correct") 39       command -nargs=1  Correct  :call s:Add(<q-args>, 0) 40     endif 41 42     let &cpo = s:save_cpo,v
"if !exists("s:call_count")"if !exists("s:call_count")"if !exists("s:call_count")"if !exists("s:call_count")"if !exists("s:call_count")"if !exists("s:call_count")"if !exists("s:call_count")"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif,v
"if !exists("s:call_count")"    let s:call_count = 0"endif""let s:call_count = s:call_count + 1""echo "called" s:call_count "times"""echo "The value of 'tabstop' is" &ts""let str = 'asdasdasdsa.'""if str =~ "\.$""    echo "contain the .""    sleep 5"endif""execute "normal Inew text \<Esc>"function Count_words() range    let n = a:firstline    let countT = 0    while n <= a:lastline        let countT = countT + Wordcount(getline(n))    endwhile    echo "found ".count." words"endfunctionfunction Number()    echo "line ".line(".")." contains ".getline(".")endfunctionfunction Show(start,...)    echohl Title    echo "Show is ". a:start    echohl None    let index = 0    while index <= a:0        echo " Arg ". index . " is " . a:{index}        let index = index + 1    endwhile    echo ""endfunctionmap ,p ma"aYHmbgg"aP`bzt`afunction s:Test(start,...)    echo a:startendfunctionif !exists(":Correct")    command -nargs=1  Correct :call s:Test(1,3,4,5)endif,V
endfunction,v
endfunction,V
excu,V
endif,v
